{"version":3,"file":"select.B5Dt1AnC.js","sources":["../../node_modules/svelte/src/internal/client/dom/elements/bindings/select.js"],"sourcesContent":["import { effect, teardown } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { is } from '../../../proxy.js';\nimport { is_array } from '../../../../shared/utils.js';\nimport * as w from '../../../warnings.js';\nimport { Batch, current_batch, previous_batch } from '../../../reactivity/batch.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} mounting\n */\nexport function select_option(select, value, mounting = false) {\n\tif (select.multiple) {\n\t\t// If value is null or undefined, keep the selection as is\n\t\tif (value == undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If not an array, warn and keep the selection as is\n\t\tif (!is_array(value)) {\n\t\t\treturn w.select_multiple_invalid_value();\n\t\t}\n\n\t\t// Otherwise, update the selection\n\t\tfor (var option of select.options) {\n\t\t\toption.selected = value.includes(get_option_value(option));\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @param {HTMLSelectElement} select\n */\nexport function init_select(select) {\n\tvar observer = new MutationObserver(() => {\n\t\t// @ts-ignore\n\t\tselect_option(select, select.__value);\n\t\t// Deliberately don't update the potential binding value,\n\t\t// the model should be preserved unless explicitly changed\n\t});\n\n\tobserver.observe(select, {\n\t\t// Listen to option element changes\n\t\tchildList: true,\n\t\tsubtree: true, // because of <optgroup>\n\t\t// Listen to option element value attribute changes\n\t\t// (doesn't get notified of select value changes,\n\t\t// because that property is not reflected as an attribute)\n\t\tattributes: true,\n\t\tattributeFilter: ['value']\n\t});\n\n\tteardown(() => {\n\t\tobserver.disconnect();\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_select_value(select, get, set = get) {\n\tvar batches = new WeakSet();\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', (is_reset) => {\n\t\tvar query = is_reset ? '[selected]' : ':checked';\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option =\n\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tset(value);\n\n\t\tif (current_batch !== null) {\n\t\t\tbatches.add(current_batch);\n\t\t}\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get();\n\n\t\tif (select === document.activeElement) {\n\t\t\t// we need both, because in non-async mode, render effects run before previous_batch is set\n\t\t\tvar batch = /** @type {Batch} */ (previous_batch ?? current_batch);\n\n\t\t\t// Don't update the <select> if it is focused. We can get here if, for example,\n\t\t\t// an update is deferred because of async work depending on the select:\n\t\t\t//\n\t\t\t// <select bind:value={selected}>...</select>\n\t\t\t// <p>{await find(selected)}</p>\n\t\t\tif (batches.has(batch)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tset(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\tinit_select(select);\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n"],"names":["select_option","select","value","mounting","multiple","undefined","is_array","w.select_multiple_invalid_value","option","options","selected","includes","get_option_value","option_value","is","selectedIndex","init_select","observer","MutationObserver","__value","observe","childList","subtree","attributes","attributeFilter","teardown","disconnect","bind_select_value","get","set","batches","WeakSet","listen_to_event_and_reset_event","is_reset","query","map","call","querySelectorAll","selected_option","querySelector","current_batch","add","effect","document","activeElement","batch","previous_batch","has"],"mappings":"kGAcO,SAASA,EAAcC,EAAQC,EAAOC,GAAW,GACvD,GAAIF,EAAOG,SAAX,CAEC,GAAaC,MAATH,EACH,OAID,IAAKI,EAASJ,GACb,OAAOK,IAIR,IAAK,IAAIC,KAAUP,EAAOQ,QACzBD,EAAOE,SAAWR,EAAMS,SAASC,EAAiBJ,GAIpD,KAjBA,CAmBA,IAAKA,KAAUP,EAAOQ,QAAS,CAC9B,IAAII,EAAeD,EAAiBJ,GACpC,GAAIM,EAAGD,EAAcX,GAEpB,YADAM,EAAOE,UAAW,EAGpB,CAEKP,QAAsBE,IAAVH,IAChBD,EAAOc,iBAXR,CAaD,CAUO,SAASC,EAAYf,GAC3B,IAAIgB,EAAW,IAAIC,kBAAiB,KAEnClB,EAAcC,EAAQA,EAAOkB,QAAQ,IAKtCF,EAASG,QAAQnB,EAAQ,CAExBoB,WAAW,EACXC,SAAS,EAITC,YAAY,EACZC,gBAAiB,CAAC,WAGnBC,GAAS,KACRR,EAASS,YAAY,GAEvB,CAQO,SAASC,EAAkB1B,EAAQ2B,EAAKC,EAAMD,GACpD,IAAIE,EAAU,IAAIC,QACd5B,GAAW,EAEf6B,EAAgC/B,EAAQ,UAAWgC,IAClD,IAEI/B,EAFAgC,EAAQD,EAAW,aAAe,WAItC,GAAIhC,EAAOG,SACVF,EAAQ,GAAGiC,IAAIC,KAAKnC,EAAOoC,iBAAiBH,GAAQtB,OAC9C,CAEN,IAAI0B,EACHrC,EAAOsC,cAAcL,IAErBjC,EAAOsC,cAAc,0BACtBrC,EAAQoC,GAAmB1B,EAAiB0B,EAC7C,CAEAT,EAAI3B,GAEkB,OAAlBsC,GACHV,EAAQW,IAAID,EACb,IAIDE,GAAO,KACN,IAAIxC,EAAQ0B,IAEZ,GAAI3B,IAAW0C,SAASC,cAAe,CAEtC,IAAIC,EAA8BC,GAAkBN,EAOpD,GAAIV,EAAQiB,IAAIF,GACf,MAEF,CAKA,GAHA7C,EAAcC,EAAQC,EAAOC,GAGzBA,QAAsBE,IAAVH,EAAqB,CAEpC,IAAIoC,EAAkBrC,EAAOsC,cAAc,YACnB,OAApBD,IACHpC,EAAQU,EAAiB0B,GACzBT,EAAI3B,GAEN,CAGAD,EAAOkB,QAAUjB,EACjBC,GAAW,CAAK,IAGjBa,EAAYf,EACb,CAGA,SAASW,EAAiBJ,GAEzB,MAAI,YAAaA,EACTA,EAAOW,QAEPX,EAAON,KAEhB","x_google_ignoreList":[0]}